/**
 * @fileoverview Apply command implementation
 *
 * Commands:
 * - tidy apply [folder]: Execute rename operations based on templates and rules
 *
 * Features:
 * - Executes renames generated by preview
 * - Interactive confirmation before execution
 * - Dry-run mode for safety
 * - Force mode to handle conflicts
 * - Automatic history recording for undo
 */
import { Command } from 'commander';
import chalk from 'chalk';
import {
  scanAndApplyRules,
  executeBatchRename,
  type ScanAndApplyOptions,
  type ExecuteRenameOptions,
  type BatchRenameResult,
  RenameStatus,
} from '@tidy/core';
import type { CliContext } from '../index.js';
import { getFolderToScan } from '../utils/path.js';
import {
  formatApplyPreview,
  formatApplyResult,
  formatApplyJson,
  formatApplyPlain,
} from '../utils/apply-format.js';
import { shouldUseColor, configureColors } from '../utils/output.js';
import { ExitCode } from '../utils/exit-codes.js';
import { createProgressReporter, createSpinner } from '../utils/progress.js';
import { confirm } from '../utils/prompts.js';

export type ApplyOutputFormat = 'table' | 'json' | 'plain';

export interface ApplyCommandOptions {
  format: ApplyOutputFormat;
  template?: string;
  withRules: boolean;
  recursive: boolean;
  extensions?: string;
  dryRun: boolean;
  yes: boolean;
  force: boolean;
  color: boolean;
  verbose: boolean;
}

/**
 * Create the apply command.
 */
export function createApplyCommand(): Command {
  const apply = new Command('apply');

  apply
    .description('Execute rename operations based on templates and rules')
    .argument('[folder]', 'Folder to process (defaults to current directory)')
    .option('-f, --format <type>', 'Output format: table, json, plain', 'table')
    .option('-t, --template <name>', 'Use a specific template by name')
    .option('-R, --with-rules', 'Apply metadata and filename pattern rules', false)
    .option('-r, --recursive', 'Process subfolders recursively', false)
    .option('-e, --extensions <list>', 'Filter by extensions (comma-separated)')
    .option('-n, --dry-run', 'Preview changes without executing', false)
    .option('-y, --yes', 'Skip confirmation prompt', false)
    .option('--force', 'Force rename even with conflicts (adds suffix)', false)
    .option('--no-color', 'Disable colored output')
    .option('-v, --verbose', 'Show detailed progress information', false)
    .addHelpText(
      'after',
      `
Output Formats:
  ${chalk.cyan('table')}   Detailed results with status indicators (default)
  ${chalk.cyan('json')}    Valid JSON with full results (for scripting)
  ${chalk.cyan('plain')}   Simple list of completed renames

Examples:
  ${chalk.gray('# Apply renames with confirmation')}
  $ tidy apply ~/Downloads

  ${chalk.gray('# Dry-run to see what would happen')}
  $ tidy apply ~/Downloads --dry-run

  ${chalk.gray('# Skip confirmation (for scripts)')}
  $ tidy apply ~/Downloads --yes

  ${chalk.gray('# Force rename with conflicts (adds suffix)')}
  $ tidy apply ~/Downloads --force

  ${chalk.gray('# Apply with specific template')}
  $ tidy apply ~/Photos --template "dated-photos" --yes

  ${chalk.gray('# Apply with rules and extensions filter')}
  $ tidy apply ~/Documents --with-rules --extensions pdf,docx

  ${chalk.gray('# Get JSON output for scripting')}
  $ tidy apply ~/Downloads --yes --format json

Related Commands:
  ${chalk.cyan('tidy preview')}   Preview renames before applying
  ${chalk.cyan('tidy undo')}      Undo the last operation
  ${chalk.cyan('tidy history')}   View operation history
`
    )
    .action(async (folder: string | undefined, options: ApplyCommandOptions, command) => {
      // Validate format option
      const validFormats: ApplyOutputFormat[] = ['table', 'json', 'plain'];
      if (!validFormats.includes(options.format)) {
        console.error(chalk.red(`Error: Invalid format '${options.format}'`));
        console.error(`Valid formats: ${validFormats.join(', ')}`);
        process.exit(ExitCode.ERROR);
      }

      // Configure colors
      const useColor = shouldUseColor({ noColor: !options.color });
      configureColors(useColor);

      // Get context for config
      const context = command.parent?.opts()._context as CliContext | undefined;

      await executeApply(folder, options, context, useColor);
    });

  return apply;
}

/**
 * Execute the apply operation.
 */
async function executeApply(
  folder: string | undefined,
  options: ApplyCommandOptions,
  context: CliContext | undefined,
  useColor: boolean
): Promise<void> {
  // Resolve folder path
  const folderResult = await getFolderToScan(folder);

  if (!folderResult.ok) {
    console.error(chalk.red(`Error: ${folderResult.error.message}`));
    process.exit(ExitCode.ERROR);
  }

  const { path: folderPath } = folderResult.data;

  // Get config
  const config = context?.config;
  if (!config) {
    console.error(chalk.red('Error: Configuration not loaded'));
    process.exit(ExitCode.ERROR);
  }

  // Parse extensions
  const extensions = options.extensions
    ? options.extensions.split(',').map((e) => e.trim().toLowerCase().replace(/^\./, ''))
    : undefined;

  // Build scan options
  const scanOptions: ScanAndApplyOptions = {
    recursive: options.recursive,
    extensions,
    baseDirectory: folderPath,
  };

  // Show progress for verbose mode
  const spinner = createSpinner();
  if (options.verbose && options.format === 'table') {
    spinner.start('Scanning and preparing renames');
  }

  // Determine template
  let effectiveConfig = config;
  if (options.template) {
    const template = config.templates.find((t) => t.name === options.template);
    if (!template) {
      spinner.stop();
      console.error(chalk.red(`Error: Template '${options.template}' not found`));
      process.exit(ExitCode.ERROR);
    }
    effectiveConfig = {
      ...config,
      preferences: {
        ...config.preferences,
        defaultTemplate: options.template,
      },
    };
  }

  // Generate preview first
  const previewResult = await scanAndApplyRules(folderPath, effectiveConfig, scanOptions);

  if (!previewResult.ok) {
    spinner.stop();
    console.error(chalk.red(`Error: ${previewResult.error.message}`));
    process.exit(ExitCode.ERROR);
  }

  const preview = previewResult.data;
  spinner.stop();

  // Filter to only ready proposals (or all if force)
  const readyProposals = options.force
    ? preview.proposals.filter((p) => p.status !== RenameStatus.NoChange)
    : preview.proposals.filter((p) => p.status === RenameStatus.Ready);

  if (readyProposals.length === 0) {
    if (options.format === 'json') {
      console.log(JSON.stringify({ success: true, renamed: 0, message: 'No files to rename' }, null, 2));
    } else if (options.format !== 'plain') {
      console.log(chalk.yellow('No files ready to rename.'));
      if (preview.summary.conflict > 0) {
        console.log(chalk.gray(`${preview.summary.conflict} file(s) have conflicts. Use --force to rename anyway.`));
      }
    }
    process.exit(ExitCode.SUCCESS);
  }

  // Show preview if not in dry-run and not auto-confirmed
  if (!options.dryRun && !options.yes && options.format === 'table') {
    console.log(formatApplyPreview(preview, { color: useColor }));
    console.log();

    // Ask for confirmation
    const confirmed = await confirm(
      `Rename ${readyProposals.length} file${readyProposals.length > 1 ? 's' : ''}?`
    );

    if (!confirmed) {
      console.log(chalk.yellow('Operation cancelled.'));
      process.exit(ExitCode.SUCCESS);
    }
    console.log();
  }

  // Dry-run mode
  if (options.dryRun) {
    if (options.format === 'json') {
      console.log(formatApplyJson({ ...createDryRunResult(readyProposals.length), dryRun: true }));
    } else if (options.format === 'plain') {
      console.log(formatApplyPlain(readyProposals));
    } else {
      console.log(formatApplyPreview(preview, { color: useColor }));
      console.log();
      console.log(chalk.cyan(`Dry-run: ${readyProposals.length} file(s) would be renamed.`));
      console.log(chalk.gray('Run without --dry-run to execute.'));
    }
    process.exit(ExitCode.SUCCESS);
  }

  // Execute the renames
  const executeOptions: ExecuteRenameOptions = {
    createDirectories: true,
    recordHistory: true,
  };

  if (options.verbose && options.format === 'table') {
    const progress = createProgressReporter();
    executeOptions.onProgress = (completed, total) => {
      progress.update('renaming', completed, total);
    };
  }

  const executeResult = await executeBatchRename(readyProposals, executeOptions);

  if (!executeResult.ok) {
    console.error(chalk.red(`Error: ${executeResult.error.message}`));
    process.exit(ExitCode.ERROR);
  }

  const result = executeResult.data;

  // Output results
  switch (options.format) {
    case 'json':
      console.log(formatApplyJson(result));
      break;
    case 'plain':
      console.log(formatApplyPlain(readyProposals, result));
      break;
    case 'table':
    default:
      console.log(formatApplyResult(result, { color: useColor }));
      break;
  }

  // Determine exit code
  if (result.summary.failed > 0 && result.summary.succeeded === 0) {
    process.exit(ExitCode.ERROR);
  } else if (result.summary.failed > 0) {
    process.exit(ExitCode.WARNING);
  } else {
    process.exit(ExitCode.SUCCESS);
  }
}

/**
 * Create a mock result for dry-run display.
 */
function createDryRunResult(count: number): BatchRenameResult {
  return {
    results: [],
    summary: {
      total: count,
      succeeded: count,
      failed: 0,
      skipped: 0,
    },
    directoriesCreated: [],
    operationId: 'dry-run',
  };
}
